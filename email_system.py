import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
import json
import schedule
import time
import os

class EmailAlertSystem:
    def __init__(self):
        """Inizializza il sistema email"""
        # Configurazione email (da config.py)
        try:
            from config import (SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAIL, 
                              SMTP_SERVER, SMTP_PORT, EMAIL_ALERTS_ENABLED)
            self.sender_email = SENDER_EMAIL
            self.sender_password = SENDER_PASSWORD
            self.recipient_email = RECIPIENT_EMAIL
            self.smtp_server = SMTP_SERVER
            self.smtp_port = SMTP_PORT
            self.email_enabled = EMAIL_ALERTS_ENABLED
        except ImportError:
            self.email_enabled = False
            print("⚠️ Configurazione email non trovata - solo alert console")
    
    def create_alert_email(self, alerts, correlations_count):
        """Crea email di alert"""
        
        subject = self.get_email_subject(alerts)
        
        # HTML per email più bella
        html_body = f"""
        <html>
        <body>
        <h2>🚨 CYBER-GEO INTELLIGENCE ALERT</h2>
        <p><strong>📅 Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        
        <h3>📊 ALERT SUMMARY:</h3>
        <ul>
        <li>🔴 <strong>Critical:</strong> {len(alerts['critical'])}</li>
        <li>🟠 <strong>High:</strong> {len(alerts['high'])}</li>
        <li>🟡 <strong>Medium:</strong> {len(alerts['medium'])}</li>
        <li>🟢 <strong>Low:</strong> {len(alerts['low'])}</li>
        <li>📈 <strong>Total Correlations:</strong> {correlations_count}</li>
        </ul>
        """
        
        # Alert critici
        if alerts['critical']:
            html_body += "<h3>🔴 CRITICAL ALERTS:</h3>"
            for i, alert in enumerate(alerts['critical'][:3]):
                html_body += f"""
                <div style="border-left: 4px solid red; padding-left: 10px; margin: 10px 0;">
                <h4>Alert #{i+1} - THREAT LEVEL: {alert['threat_level']}</h4>
                <p><strong>Score:</strong> {alert['score']}</p>
                <p><strong>🔒 CYBER:</strong> {alert['cyber_title']}</p>
                <p><strong>🌍 GEO:</strong> {alert['geo_title']}</p>
                <p><strong>🔍 ANALYSIS:</strong> {alert['analysis']}</p>
                </div>
                """
        
        # Alert high
        if alerts['high']:
            html_body += "<h3>🟠 HIGH PRIORITY ALERTS:</h3>"
            for i, alert in enumerate(alerts['high'][:2]):
                html_body += f"""
                <div style="border-left: 4px solid orange; padding-left: 10px; margin: 10px 0;">
                <h4>Alert #{i+1} - THREAT LEVEL: {alert['threat_level']}</h4>
                <p><strong>Score:</strong> {alert['score']}</p>
                <p><strong>🔒 CYBER:</strong> {alert['cyber_title']}</p>
                <p><strong>🌍 GEO:</strong> {alert['geo_title']}</p>
                <p><strong>🔍 ANALYSIS:</strong> {alert['analysis']}</p>
                </div>
                """
        
        html_body += """
        <hr>
        <p><em>🤖 Generated by Cyber-Geo News Aggregator</em></p>
        <p><em>📁 Full data available in JSON files</em></p>
        </body>
        </html>
        """
        
        return subject, html_body
    
    def get_email_subject(self, alerts):
        """Genera subject dell'email basato sui livelli di alert"""
        
        critical_count = len(alerts['critical'])
        high_count = len(alerts['high'])
        
        if critical_count > 0:
            return f"🚨 CRITICAL CYBER-GEO THREAT - {critical_count} Alert(s)"
        elif high_count > 0:
            return f"⚠️ HIGH Priority Cyber-Geo Alert - {high_count} Alert(s)"
        else:
            return f"📊 Cyber-Geo Intelligence Update - {datetime.now().strftime('%Y-%m-%d')}"
    
    def send_email(self, subject, html_body):
        """Invia email di alert"""
        
        if not self.email_enabled:
            print("📧 Email disabilitate - mostro solo in console")
            return False
        
        try:
            # Crea messaggio
            msg = MIMEMultipart('alternative')
            msg['From'] = self.sender_email
            msg['To'] = self.recipient_email
            msg['Subject'] = subject
            
            # Aggiungi HTML
            html_part = MIMEText(html_body, 'html')
            msg.attach(html_part)
            
            # Invia email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.sender_email, self.sender_password)
                server.send_message(msg)
            
            print(f"✅ Email alert inviata a {self.recipient_email}")
            return True
            
        except Exception as e:
            print(f"❌ Errore invio email: {e}")
            return False
    
    def should_send_alert(self, alerts):
        """Decide se inviare alert basato sui livelli"""
        
        # Invia sempre se ci sono alert critici o high
        if alerts['critical'] or alerts['high']:
            return True
        
        # Invia se ci sono molti alert medium
        if len(alerts['medium']) >= 5:
            return True
        
        return False

def create_weekly_report():
    """Crea report settimanale"""
    
    print("📊 Generando report settimanale...")
    
    # Trova tutti i file di alert dell'ultima settimana
    week_ago = datetime.now() - timedelta(days=7)
    alert_files = []
    
    for filename in os.listdir('.'):
        if filename.startswith('alerts_') and filename.endswith('.json'):
            try:
                # Estrai data dal filename
                date_str = filename.split('_')[1][:8]  # YYYYMMDD
                file_date = datetime.strptime(date_str, '%Y%m%d')
                if file_date >= week_ago:
                    alert_files.append(filename)
            except:
                continue
    
    # Aggrega statistiche settimanali
    weekly_stats = {
        'total_alerts': 0,
        'critical_alerts': 0,
        'high_alerts': 0,
        'top_threats': [],
        'trending_keywords': {},
        'active_days': len(alert_files)
    }
    
    for filename in alert_files:
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
                weekly_stats['total_alerts'] += sum(len(data[level]) for level in data)
                weekly_stats['critical_alerts'] += len(data.get('critical', []))
                weekly_stats['high_alerts'] += len(data.get('high', []))
        except:
            continue
    
    # Crea report HTML
    report_html = f"""
    <html>
    <body>
    <h1>📊 WEEKLY CYBER-GEO INTELLIGENCE REPORT</h1>
    <h2>📅 Period: {week_ago.strftime('%Y-%m-%d')} to {datetime.now().strftime('%Y-%m-%d')}</h2>
    
    <h3>📈 WEEKLY STATISTICS:</h3>
    <ul>
    <li><strong>Total Alerts:</strong> {weekly_stats['total_alerts']}</li>
    <li><strong>Critical Alerts:</strong> {weekly_stats['critical_alerts']}</li>
    <li><strong>High Priority Alerts:</strong> {weekly_stats['high_alerts']}</li>
    <li><strong>Active Monitoring Days:</strong> {weekly_stats['active_days']}</li>
    </ul>
    
    <h3>🎯 KEY INSIGHTS:</h3>
    <p>• Average {weekly_stats['total_alerts'] / max(weekly_stats['active_days'], 1):.1f} alerts per day</p>
    <p>• {weekly_stats['critical_alerts'] + weekly_stats['high_alerts']} high-priority threats detected</p>
    
    <hr>
    <p><em>🤖 Generated automatically by Cyber-Geo News Aggregator</em></p>
    </body>
    </html>
    """
    
    # Salva report
    report_filename = f"weekly_report_{datetime.now().strftime('%Y%m%d')}.html"
    with open(report_filename, 'w', encoding='utf-8') as f:
        f.write(report_html)
    
    print(f"📄 Report settimanale salvato: {report_filename}")
    return report_html

def run_monitoring_cycle():
    """Esegue un ciclo completo di monitoraggio"""
    
    print(f"\n🔄 Ciclo monitoraggio - {datetime.now().strftime('%H:%M:%S')}")
    
    # Esegui analisi
    from alert_system import run_full_analysis
    alerts, correlations = run_full_analysis()
    
    # Sistema email
    email_system = EmailAlertSystem()
    
    # Controlla se inviare alert
    if email_system.should_send_alert(alerts):
        subject, html_body = email_system.create_alert_email(alerts, len(correlations))
        email_system.send_email(subject, html_body)
    else:
        print("📧 Nessun alert urgente - email non inviata")
    
    return alerts, correlations

def setup_automated_monitoring():
    """Configura monitoraggio automatico"""
    
    print("⏰ Configurando monitoraggio automatico...")
    
    # Monitoraggio ogni ora
    schedule.every().hour.do(run_monitoring_cycle)
    
    # Report settimanale ogni domenica alle 09:00
    schedule.every().sunday.at("09:00").do(create_weekly_report)
    
    print("✅ Monitoraggio automatico configurato:")
    print("   • Alert ogni ora")
    print("   • Report settimanale domenica 09:00")
    
    # Esegui primo ciclo
    print("\n🚀 Eseguendo primo ciclo...")
    run_monitoring_cycle()
    
    # Loop infinito
    print("\n⏰ Monitoraggio attivo - Ctrl+C per fermare")
    try:
        while True:
            schedule.run_pending()
            time.sleep(60)  # Controlla ogni minuto
    except KeyboardInterrupt:
        print("\n🛑 Monitoraggio fermato")

if __name__ == "__main__":
    # Test sistema email
    print("🧪 Test sistema email...")
    
    # Esegui analisi
    from alert_system import run_full_analysis
    alerts, correlations = run_full_analysis()
    
    # Test email
    email_system = EmailAlertSystem()
    subject, html_body = email_system.create_alert_email(alerts, len(correlations))
    
    print(f"\n📧 EMAIL PREVIEW:")
    print(f"Subject: {subject}")
    print("Body preview generato ✅")
    
    # Salva preview HTML
    with open('email_preview.html', 'w', encoding='utf-8') as f:
        f.write(html_body)
    print("📄 Email preview salvata: email_preview.html")
    
    # Crea report settimanale
    create_weekly_report()